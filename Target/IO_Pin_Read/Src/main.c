/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 * In this program we will read the IO pin from the board(PA0) which is connected
 * the GPIO Port A and the pin is 0
 ******************************************************************************/

#include<stdio.h>
#include<stdint.h>

int main()
{
 //portA configuration
 uint32_t *pClkCtrlReg = (uint32_t*) 0x40023830; // Base addr: 0x40023800 + Offset for Peripheral Enable 0x30
 uint32_t *pPortAModeReg = (uint32_t*) 0x40020000;
 uint32_t *pPortADataInReg = (uint32_t*) 0x40020010; // read-only register

 //portD Configuration
// uint32_t *pClkCtrlReg = (uint32_t*) 0x40023830;
 uint32_t *pPortDModeReg = (uint32_t*) 0x40020C00;
 uint32_t volatile *pPortDDataOutReg = (uint32_t*) 0x40020C14;// in O0 level optimization we do not need volatile
 // for 01 level of optimization we need ti use volatile becuase the compiler uses the status of the pin previously saved.

 //enable clk for both PortA and Port D
 *pClkCtrlReg =(9<<0);

 //set the mode reg for both PortA and PortD
 *pPortAModeReg &= ~(3<<0); //configuring PortA as input mode
 *pPortDModeReg = ~(3<<24); // clearing the bits 24 and 25 use bitwise AND
 *pPortDModeReg =  (1<<24); // set 24th bit to high to pout it to output mode use bitwise OR

 while(1)
 {
 //read the GPIOA register using GPIOInputData Register
 uint8_t PinStatus = (uint8_t)(*pPortADataInReg & 0x1);

 //try the logic if PortA is high the LED should glow
 if(PinStatus)
 	{
	 *pPortDDataOutReg = (1<<12); //turn on the led
 	}
 else
	{
	 *pPortDDataOutReg = ~(1<<12);
	}
 }
}
